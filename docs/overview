@page overview High level overview of KLEE. This document contains a high level overview of the inner workings of KLEE.
KLEE的高级概览。本文档包含KLEE内部工作的高级概述。

KLEE implements symbolic execution by interpreting LLVM bitcode. Symbolic memory is defined by inserting special calls to KLEE (namely klee_make_symbolic) During execution, KLEE tracks all uses of symbolic memory. Constraints on symbolic memory usage are collected. Memory that is defined using previously declared symbolic memory become symbolic as well. Whenever a branch refering to symbolic memory is encountered, KLEE forks the entire states and explores each side of the branch for which a possible solution to the symbolic constraints can be found. KLEE makes queries to STP to solve symbolic constraints.
KLEE通过解释LLVM位码来实现符号执行。符号内存的定义是在执行期间插入对KLEE的特殊调用(即klee_make_symbolic)， KLEE跟踪所有符号内存的使用。收集符号内存使用的约束。使用先前声明的符号内存定义的内存也成为符号内存。每当遇到涉及到符号内存的分支时，KLEE就分叉整个状态，并探索分支的每一边，以便找到符号约束的可能解决方案。KLEE对STP进行查询来解决符号约束。

The rest of this document describes some of the important components of KLEE
本文的其余部分将介绍KLEE的一些重要组件

@section executor Interpreter klee::Interpreter is the main abstract class defining the interface of the bitcode interpreter. klee::Executor is the main concrete instance of this class. Application states (i.e. memory, registers and PC) are stored in instances of class klee::ExecutionState. There is one such instance for each path beeing executed (except when some states are merged together). On a branch, if condition is symbolic, klee::Executor::fork returns a klee::ExecutionState::StatePair which is a pair of ExecutionState to be executed.
klee::解释器是定义位码解释器接口的主要抽象类。Executor是这个类的主要具体实例。应用程序状态(即内存、寄存器和PC)存储在类klee::ExecutionState的实例中。对于执行的每个路径都有一个这样的实例(除非某些状态合并在一起)。在分支上，如果条件是符号的，那么klee::Executor::fork将返回一个klee::ExecutionState::StatePair，它是要执行的一对ExecutionState。

@section memory Memory model MemoryObject's represent allocation sites in the program (calls to malloc, stack objects, global variables) and, at least conceptually, can be thought of as the unique name for the object allocated at that site. ObjectState's are used to store the actual contents of a MemoryObject in a particular ExecutionState (but can be shared). I need better names for these two things.
@section内存内存模型MemoryObject表示程序中的分配站点(调用malloc、堆栈对象、全局变量)，至少在概念上可以认为是在该站点上分配的对象的惟一名称。ObjectState用于将MemoryObject的实际内容存储在特定的ExecutionState中(但可以共享)。我需要给这两样东西取个更好的名字。

Each ExecutionState stores a mapping of MemoryObjects -> ObjectState using the AddressSpace data structure (implemented as an immutable tree so that copying is cheap and the shared structure is exploited). Each AddressSpace may "own" some subset of the ObjectStates in the mapping. When an AddressSpace is duplicated it loses ownership of the ObjectState in the map. Any subsequent write to an ObjectState will create a copy of the object (AddressSpace::getWriteable). This is the COW mechanism (which gets used for all objects, not just globals).
每个执行状态存储内存对象的一个映射-&gt;ObjectState使用AddressSpace数据结构(实现为不可变树，因此复制成本很低，共享结构也被利用)。每个AddressSpace可能“拥有”映射中ObjectStates的某个子集。当一个地址空间被复制时，它将失去映射中ObjectState的所有权。对ObjectState的任何后续写操作都将创建该对象的副本(AddressSpace::getWriteable)。这是COW机制(用于所有对象，而不仅仅是全局对象)。

From the point of view of the state and this mapping there is no distinction between stack, heap, and global objects. The only special handling for stack objects is that the MemoryObject is marked as isLocal and the MemoryObject is stored in the StackFrame alloca list. When the StackFrame is popped these objects are then unbound so that the state can no longer access the memory directly (references to the memory object may still remain in ReadExprs, but conceptually the actual memory is no longer addressable).
从状态和映射的角度来看，栈、堆和全局对象之间没有区别。堆栈对象的惟一特殊处理是将MemoryObject标记为isLocal，而MemoryObject存储在StackFrame alloca列表中。当StackFrame被弹出时，这些对象将被解除绑定，这样状态就不再能够直接访问内存(对内存对象的引用可能仍然保留在ReadExprs中，但是从概念上讲，实际的内存不再是可寻址的)。

It is also important that the AddressSpace mapping is ordered. We use this when we need to resolve a symbolic address to an ObjectState by first getting a particular value for the symbolic address, and using that value to start looking for objects that the pointer can fall within. Difference betweens MemoryObjects and ObjectStates ?
还有一点很重要，即AddressSpace映射是有序的。当我们需要将一个符号地址解析为ObjectState时，我们使用这个方法，首先为这个符号地址获取一个特定的值，然后使用这个值来开始查找指针可能所属的对象。内存对象和对象状态之间的区别?

@section expression Expressions The various Expr classes mostly model the llvm instruction set. ref<Expr> is used to maintain the reference count but also embeds any constant expressions. In fact in the current code base ConstantExprs should almost never be created. Most of the Expr's are straightforward. Some of the most important ones are Concat?Expr, which join some number of bytes into a larger type, ExtractExpr which extracts smaller types from larger ones, and ReadExpr which is a symbolic array access.
各种Expr类主要对llvm指令集进行建模。用于维护引用计数，但也嵌入任何常数表达式。事实上，在当前的代码库中，ConstantExprs几乎不应该被创建。大多数Expr都很简单。其中一些最重要的是Concat?Expr，它将一些字节连接到一个较大的类型中，ExtractExpr从较大的类型中提取较小的类型，ReadExpr是一个符号数组访问。

The way memory is implemented all accesses are broken down into byte level operations. This means that the memory system (by which I mean the ObjectState data structure) tends to use a lot of ExtractExpr and Concat?Expr, so it is very important that these expressions fold their operands when possible.
内存的实现方式将所有访问分解为字节级的操作。这意味着内存系统(这里我指的是ObjectState数据结构)倾向于使用大量ExtractExpr和Concat?因此，在可能的情况下，这些表达式折叠它们的操作数是非常重要的。

The ReadExpr is probably the most important one. Conceptually it is simply an index and a list of (index, value) updates (writes). The ReadExpr evaluates to all the values for which the two indices can be equal. The ObjectState structure uses a cache for concrete writes and for symbolic writes at concrete indices, but for writes at symbolic indices it must construct a list of such updates. These are stored in the UpdateList and UpdateNode structures which are again immutable data structures so that copy is cheap and the sharing is exploited.
ReadExpr可能是最重要的一个。从概念上讲，它只是一个索引和一个(索引、值)更新(写)列表。ReadExpr计算两个索引可以相等的所有值。ObjectState结构使用一个缓存来进行具体的写操作和针对具体索引的符号写操作，但是对于针对符号索引的写操作，它必须构造这样的更新列表。这些数据被存储在UpdateList和UpdateNode结构中，这两个结构也是不可变的数据结构，因此复制成本很低，并且可以利用共享。

@section searcher Searcher Base classe: klee::Searcher. The Executor uses a Searcher to select the next state (i.e. program instance following a single path) for which an instruction will be executed. There are multiple implementations of Searcher in klee, implementing different search policies. klee::RandomSearcher selects the next state randomly. klee::DFSSearcher uses a depth first approach. klee::MergingSearcher tries to merge states ?
@section searcher searcher Base classe: klee:: searcher。执行程序使用一个搜索程序来选择下一个执行指令的状态(例如，沿着单一路径的程序实例)。在klee中有多种Searcher实现，实现了不同的搜索策略。RandomSearcher随机选择下一个状态。DFSSearcher使用深度优先方法。MergingSearcher试图合并状态?
